using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;

namespace DynamicCSharp
{
    /// <summary>
    /// Class to manage a conversion of source
    /// code into a dynamically loaded assembly
    /// </summary>

    public class Compiler : ICompiler
    {
        /// <summary>
        /// Factory method
        /// </summary>
        /// <returns>A new instance of the compiler
        /// expressed through the ICompiler interface</returns>

        public static ICompiler Create() => new Compiler();

        /// <summary>
        /// The assembly generated and loaded from this compilation
        /// </summary>

        public Assembly Assembly { get; private set; }

        /// <summary>
        /// The semantic analysis of this compilation
        /// </summary>

        public SemanticModel SemanticModel { get; private set; }

        /// <summary>
        /// The compilation output
        /// </summary>

        public Compilation Compilation { get; private set; }

        /// <summary>
        /// The generated C# syntax tree for this compilation
        /// </summary>

        public SyntaxTree SyntaxTree { get; set; }

        /// <summary>
        /// The input source code to be compiled
        /// </summary>

        public string Source { get; set; }

        /// <summary>
        /// The input stream for source code. Takes
        /// precedence over the Source string property
        /// if non-null.
        /// </summary>

        public Stream SourceStream { get; set; }

        /// <summary>
        /// The name chosen for the output assembly
        /// </summary>

        public string AssemblyName { get; set; }

        /// <summary>
        /// The list of warnings and errors generated by this compilation
        /// </summary>

        public IEnumerable<Diagnostic> Diagnostics { get; private set; }

        /// <summary>
        /// Add a reference to the assembly containing the
        /// definition of the type t. The type T must be in
        /// an assembly that is loaded and known to the
        /// current application.
        /// </summary>
        /// <param name="t">The type we need to reference</param>

        public void AddReference(Type t)
        {
            if (t == null)
                throw new ArgumentException("Adding reference to null type");

            var mdRef = MetadataReference.CreateFromFile(t.GetTypeInfo().Assembly.Location)
                    ?? throw new ArgumentException("Metadata reference not found");
            metaDataReferences.Add(mdRef);
        }

        /// <summary>
        /// Add a reference to the assembly containing
        /// the definition of the type with name typeName.
        /// The type T must be in an assembly loaded in the
        /// currently running application.
        /// </summary>
        /// <param name="typeName">The name of the type
        /// we need to reference</param>

        public void AddReference(string typeName)
        {
            AddReference(Type.GetType(typeName, true));
        }

        /// <summary>
        /// Add references to each of a list of types
        /// </summary>
        /// <param name="typeNames">The names of each of the types
        /// we wish to reference</param>

        public void AddReferences(IEnumerable<string> typeNames)
        {
            if (typeNames != null)
                foreach (string tn in typeNames)
                    AddReference(tn);
        }

        private string[] trustedAssemblyPaths = null;

        /// <summary>
        /// Add a reference to the assembly with
        /// the specified file name or path
        /// </summary>
        /// <param name="assemblyName">The name of the DLL
        /// we need to reference</param>

        public void AddAssemblyReference(string assemblyName)
        {
            // Deal with unnecesary extensions

            if (assemblyName.EndsWith(".dll", true, null))
                assemblyName = Path.GetFileNameWithoutExtension(assemblyName);

            // First search for the assembly among the list of trusted
            // assemblies alrady known about by the .NET core installation

            trustedAssemblyPaths ??=
                    ((string)AppContext.GetData("TRUSTED_PLATFORM_ASSEMBLIES"))
                    .Split(Path.PathSeparator);
            string assemblyPath = trustedAssemblyPaths
                .FirstOrDefault(p => string.Compare(assemblyName,
                Path.GetFileNameWithoutExtension(p), true) == 0);

            // Now try and load the assembly using the
            // inbuilt assembly resolution mechanism,
            // if the assembly was not listed among the
            // trusted assemblies.

            if (string.IsNullOrEmpty(assemblyPath))
                throw new ArgumentException("Assembly path not found in trusted assmeblies");
            var mdRef = MetadataReference.CreateFromFile(assemblyPath)
                ?? throw new ArgumentException("Metadata reference not found");
            metaDataReferences.Add(mdRef);
        }

        /// <summary>
        /// Add references to each of a list of assembly file names
        /// </summary>
        /// <param name="assemblyNames">The names of each of the assmebly DLLs
        /// we wish to reference</param>

        public void AddAssemblyReferences(IEnumerable<string> assemblyNames)
        {
            if (assemblyNames != null)
                foreach (string an in assemblyNames)
                    AddAssemblyReference(an);
        }

        /// <summary>
        /// Compile the source code in the Source
        /// property into a loaded dynamic assembly
        /// </summary>
        /// <param name="dbgMode">Whether to compile as a
        /// debug assembly or a release assembly</param>

        public void Compile(bool dbgMode = false)
        {
            if (SyntaxTree == null)
            {
                // Decide where the source code is coming from. If the
                // SourceStream property is non-null, source code is read
                // from there. Otherwise it comes from the Source property.

                if (SourceStream != null)
                {
                    using var ipTextReader = new StreamReader(SourceStream);
                    Source = ipTextReader.ReadToEnd();
                }

                if (string.IsNullOrWhiteSpace(Source))
                    throw new InvalidOperationException("No source code to compile");

                GenerateSyntaxTree();
            }

            var options = new CSharpCompilationOptions
                (
                    OutputKind.DynamicallyLinkedLibrary,
                    optimizationLevel: dbgMode ? OptimizationLevel.Debug : OptimizationLevel.Release,
                    allowUnsafe: true
                );
            Compilation = CSharpCompilation.Create
                (AssemblyName, Enumerable.Repeat(SyntaxTree, 1), metaDataReferences, options);
            SemanticModel = Compilation.GetSemanticModel(SyntaxTree);
            Diagnostics = SemanticModel.GetDiagnostics();
            if (!HasErrors)
                EmitAssembly(dbgMode);
        }

        /// <summary>
        /// True if the compilation raised any errors
        /// </summary>

        public bool HasErrors
        {
            get
            {
                return Diagnostics.Any
                    (d => d.Severity == DiagnosticSeverity.Error || d.IsWarningAsError);
            }
        }

        private readonly List<MetadataReference> metaDataReferences = [];

        // Make the constructor private to force all creation to
        // go via the factory method. This in turn ensures users
        // get access to an ICompiler rather than a Compiler

        private Compiler() { }

        private void GenerateSyntaxTree()
        {
            var cSharpVersion = Enum
                .GetValues<LanguageVersion>()
                .Cast<LanguageVersion>()
                .Max();
            var parseOptions = new CSharpParseOptions
                (cSharpVersion, DocumentationMode.Parse, SourceCodeKind.Regular);
            SyntaxTree = CSharpSyntaxTree.ParseText(Source, parseOptions, string.Empty);
        }

        private void EmitAssembly(bool dbgMode = false)
        {
            using var outputStream = new MemoryStream();
            using var debugStream = new MemoryStream();
            Compilation.Emit(outputStream, debugStream);
            outputStream.Flush();
            outputStream.Seek(0, SeekOrigin.Begin);
            debugStream.Flush();
            debugStream.Seek(0, SeekOrigin.Begin);
            if (dbgMode)
                Assembly = AssemblyLoadContext.Default.LoadFromStream(outputStream, debugStream);
            else
                Assembly = AssemblyLoadContext.Default.LoadFromStream(outputStream);
        }
    }
}