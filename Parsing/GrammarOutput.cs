// This source code is based on code written for Ropley Information
// Technology Ltd. (RIT), and is offered for public use without warranty.
// You are entitled to edit or extend this code for your own purposes,
// but use of any unmodified parts of this code does not grant
// the user exclusive rights or ownership of that unmodified code. 
// While every effort has been made to deliver quality software, 
// there is no guarantee that this product offered for public use
// is without defects. The software is provided "as is," and you 
// use the software at your own risk. No warranties are made as to 
// performance, merchantability, fitness for a particular purpose, 
// nor are any other warranties expressed or implied. No oral or 
// written communication from or information provided by RIT 
// shall create a warranty. Under no circumstances shall RIT
// be liable for direct, indirect, special, incidental, or 
// consequential damages resulting from the use, misuse, or 
// inability to use this software, even if RIT has been
// advised of the possibility of such damages. Downloading
// opening or using this file in any way will constitute your 
// agreement to these terms and conditions. Do not use this 
// software if you do not agree to these terms.

using BooleanLib;
using ParserGenerator;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Parsing
{
    /// <summary>
    /// Static code generated implementation
    /// of LR(1) parser output
    /// </summary>

    public class GrammarOutput : IGrammarOutput
    {
        private readonly string banner =
            "// AUTOGENERATED CODE FROM PARSELR PARSER-GENERATOR. DO NOT EDIT.\r\n" +
            "//\r\n" +
            "// Date generated: {0:r}\r\n" +
            "// This code represents the hidden derived class from the\r\n" +
            "// application-specific parser class, itself derived from\r\n" +
            "// Parsing.Parser. There should be no need to edit this file.\r\n" +
            "\r\n" +
            "#nullable enable // Allow nullable types in auto-generated code\r\n" +
            "\r\n";

        private readonly TextWriter sourceFile;

        public GrammarOutput(TextWriter srcFile)
        {
            if (srcFile == null)
                throw new ArgumentException("Need a valid output stream to write source code");
            else
                sourceFile = srcFile;
        }

        // Names of classes containing guard and action functions

        private string nameSpace = "Parsing";
        private string appSpecificParserClassName = "LRParser";
        private Grammar grammar;
        private int[] writtenGuards;
        private int guardIndex;
        private bool useErrorRecovery;

        /// <summary>
        /// Given the list of item sets in the grammar
        /// and the list of productions, generate the
        /// necessary output code that will become the
        /// parser for the grammar.
        /// </summary>
        /// <param name="gram">The data structures
        /// that define the grammar to be rendered</param>  
        /// <param name="verbose">True to include more debugging
        /// information in the output state strings</param>
        /// <param name="errRecovery">True to enable the
        /// stack-unravelling error handler in the output
        /// parser tables</param>
        /// <param name="isGLR">Set true to generate
        /// output code for a Generalised LR(1) parser
        /// that can support ambiguous grammars. Set
        /// false for traditional LR(1) parsers.</param>

        public void RenderStateTables(Grammar gram, bool verbose, bool errRecovery, bool isGLR)
        {
            if (gram == null)
                throw new ArgumentNullException(nameof(gram), "A valid Grammar object is required");
            else
                grammar = gram;

            // Choose the parser base class based on the type of parser

            //if (isGLR)
            //    parserBaseClassNameDecorator = "Generalised";

            useErrorRecovery = errRecovery;

            // Capture the options from the dictionary

            List<string> usings = null;

            // First render the banner at the top of the new source file

            sourceFile.Write(banner, DateTime.Now);

            // Pull in the using namespaces and the
            // namespace for the parser if available

            if (grammar.Options != null)
            {
                if (grammar.Options.TryGetValue("usings", out object value))
                    usings = value as List<string>;
                if (grammar.Options.TryGetValue("namespace", out value))
                    nameSpace = value.ToString();
                if (grammar.Options.TryGetValue("parserclass", out value))
                    appSpecificParserClassName = value.ToString();
            }

            // If the user has set parser-generated
            // alternatives for the list of using
            // statements, use these. Otherwise, use
            // a default set that will allow the
            // parser to compile successfully.

            if (usings != null && usings.Count > 0)
                foreach (string u in usings)
                    sourceFile.WriteLine($"using {u};");
            else
            {
                sourceFile.Write(
                    "using System;\r\n" +
                    "using System.Collections.Generic;\r\n" +
                    "using System.Linq;\r\n" +
                    "using System.Text;\r\n" +
                    "using System.IO;\r\n" +
                    "using Parsing;\r\n");
            }

            // Output the namespace name to be used at the
            // top of the parser. By default this is
            // LRParser at the top namespace level.

            sourceFile.WriteLine($"\r\nnamespace {nameSpace}.AutoGenerated\r\n{{");

            // Output the parser state tables

            RenderParserTablePrefix();

            // Output the grammar productions list first

            foreach (GrammarProduction p in gram.Productions.OrderBy(gp => gp.ProductionNumber))
                RenderNewProduction(p, gram.Productions);
            RenderProductionsSuffix();

            // Create a new array index list for the guard functions,
            // and initialise them to -1 which represents the unset value

            writtenGuards = new int[gram.BooleanExpressionCache.Count];
            for (int i = 0; i < writtenGuards.Length; i++)
                writtenGuards[i] = -1;

            // Output the parser states

            foreach (GrammarItemSet gis in gram.ItemSets.OrderBy(i => i.SetNumber))
                RenderParserState(gis, verbose);
            RenderMergeActions();
            RenderParserStatesSuffix();
        }

        private void RenderParserTablePrefix()
        {
            string prefix =
                "    /// <summary>\r\n" +
                "    /// Implements the auto-generated part of the user-specific\r\n" +
                "    /// parser class. This gives the action functions and guards\r\n" +
                "    /// in-class access to the contents of the user-specific parser.\r\n" +
                "    /// </summary>\r\n" +
                "\r\n" +
                $"    public class {appSpecificParserClassName}_AutoGenerated : {appSpecificParserClassName}\r\n" +
                $"    {{\r\n" +
                "        /// <summary>\r\n" +
                "        /// Initialiser for source-code parser\r\n" +
                "        /// generator that is subsequently compiled to\r\n" +
                "        /// obtain the new run-time code.\r\n" +
                "        /// </summary>\r\n" +
                "\r\n" +
                "        public static ParserTable InitParserTable()\r\n" +
                $"        {{\r\n" +
                "            ParserTable table = new ParserTable();\r\n" +
                "\r\n" +
                "            // Initialize the parser factory delegate\r\n" +
                "\r\n" +
                $"            table.InitializeParserConstructor(typeof({appSpecificParserClassName}_AutoGenerated));\r\n" +
                "\r\n" +
                "            table.Tokens = new TwoWayMap<string, int>();\r\n";

            string productionsPrefix =
                "            table.Guards = InitGuards();\r\n" +
                "\r\n" +
                "            table.Productions = new ParserProduction[]\r\n" +
                "            {\r\n";

            sourceFile.Write(prefix);

            // Output the flag that indicates whether the output parser
            // should support yacc/bison style error recovery

            string strUseErrRec = useErrorRecovery ? "true" : "false";
            sourceFile.Write($"            table.ErrorRecoveryEnabled = {strUseErrRec};\r\n");

            RenderTokenNames();
            sourceFile.Write(productionsPrefix);
        }

        private void RenderTokenNames()
        {
            // First render the token types enum

            sourceFile.Write("\r\n            // Terminal token names and values\r\n\r\n");

            // Create the terminal token members of the enum

            foreach (GrammarToken tok in grammar.Terminals.OrderBy(t => t.TokenNumber))
                sourceFile.Write($"            table.Tokens.Add(\"{tok.Text}\", {tok.TokenNumber});\r\n");

            // Render the lines that fit between the terminal
            // and non-terminal tokens

            sourceFile.Write(
                "\r\n" +
                "            // Non-terminal token names and values\r\n" +
                "\r\n");

            // Now output the non terminal symbols

            foreach (GrammarToken ntTok in grammar.Nonterminals.OrderBy(t => t.TokenNumber))
                sourceFile.Write($"            table.Tokens.Add(\"{ntTok.Text}\", {ntTok.TokenNumber});\r\n");

            sourceFile.WriteLine();
        }

        private void RenderProductionsSuffix()
        {
            string pSuffix =
                "            };\r\n" +
                "\r\n" +
                "            table.States = new ParserState[]\r\n" +
                "            {\r\n";

            sourceFile.Write(pSuffix);
        }

        private void RenderMergeActions()
        {
            string mergePrefix =
                "\r\n" +
                "            // Initialize the GLR Parser merge table\r\n" +
                "\r\n" +
                "            table.MergeActions = new Dictionary<int, ParserMergeAction>();\r\n";

            sourceFile.Write("            };\r\n");
            if (grammar.MergeActions.Keys.Count > 0)
            {
                sourceFile.Write(mergePrefix);
                foreach (string key in grammar.MergeActions.Keys)
                {
                    // Find the token number allocated
                    // to this non-terminal identifier

                    int tokenNumber = 0;
                    GrammarToken tok = grammar.Nonterminals.FirstOrDefault(nt => nt.Text == key);
                    if (tok != null)
                        tokenNumber = tok.TokenNumber;
                    string methodName = grammar.MergeActions[key].Name;
                    if (string.IsNullOrEmpty(methodName))
                        methodName = $"Merge{key}";
                    sourceFile.Write(
                        $"            table.MergeActions.Add({tokenNumber}, " +
                        $"new ParserMergeAction(\"{methodName}\"));  // Merge action for {key}\r\n");
                }
            }
            sourceFile.Write(
                "\r\n" +
                "            return table;\r\n" +
                "        }\r\n");

            // Now render any merge actions themselves

            foreach (string key in grammar.MergeActions.Keys)
            {
                RenderInlineMergeAction(key, grammar.MergeActions[key]);
            }
        }

        private void RenderParserStatesSuffix()
        {
            string guardPrefix =
                "\r\n" +
                "        // Initialize the guard condition evaluator functions\r\n" +
                "\r\n" +
                "        private static IGuardEvaluator[] InitGuards()\r\n" +
                "        {\r\n" +
                "            return new IGuardEvaluator[]\r\n" +
                "            {\r\n";

            string psSuffix =
                "            };\r\n" +
                "        }\r\n" +
                "\r\n" +
                "        // The action functions taken from the inline code fragments\r\n" +
                "        // after the grammar rules, and used when rules are reduced.\r\n" +
                "\r\n" +
                $"{actionProcs}";

            string fileSuffix =
                "    }\r\n" +
                "}";

            sourceFile.Write(guardPrefix);
            sourceFile.Write(guardProcs.ToString());
            sourceFile.Write(psSuffix);
            RenderGuardFunctions(grammar.GuardBodies);
            sourceFile.WriteLine(fileSuffix);
        }

        /// <summary>
        /// Append the list of inline guard functions
        /// onto the end of the parser class.
        /// </summary>
        /// <param name="list">The list of identified guards</param>

        private void RenderGuardFunctions(List<GrammarGuardOrAction> list)
        {
            List<GrammarGuardOrAction> inlineGuards = list.Where(gg => !string.IsNullOrEmpty(gg.Code)).ToList();
            if (inlineGuards.Count > 0)
                sourceFile.Write(
                    "\r\n" +
                    "        // Guard functions captured from in-line code in grammar\r\n");

            foreach (GrammarGuardOrAction gg in inlineGuards)
            {
                if (string.IsNullOrEmpty(gg.GuardType))
                    sourceFile.Write(
                        "\r\n" +
                        $"        public bool {gg.Name}(object _tokenVal)\r\n" +
                        "        {\r\n");
                else
                    sourceFile.Write(
                        "\r\n" +
                        $"        public bool {gg.Name}(object arg)\r\n" +
                        "        {\r\n" +
                        $"            {gg.GuardType} _tokenVal = ({gg.GuardType})arg;\r\n");

                // Perform parameter substitution for guard function. The
                // special identifier $token represents the value of the
                // input token that the guard condition is being applied to.

                string code = Regex.Replace(gg.Code, @"\$token", "_tokenVal");
                code = Regex.Replace(code, @"\$0", "_tokenVal");

                // Now transform the code from the grammar format
                // to a valid output method

                sourceFile.Write(RationaliseCode(code));
                sourceFile.Write("        }\r\n");
            }
        }

        private void RenderParserState(GrammarItemSet gis, bool verbose)
        {
            string psPrefix =
                "                new ParserState\r\n" +
                "                {\r\n" +
                "                    StateString =\r\n";
            sourceFile.Write(psPrefix);
            sourceFile.WriteLine($"{RenderAsCSharpString(6, gis.ToString(verbose))},\r\n");

            bool hasShifts = gis.ShiftCount > 0;
            bool hasReductions = gis.ReductionCount > 0;
            bool hasGotos = gis.GotoCount > 0;

            if (hasShifts || hasReductions)
            {
                string tcPrefix =
                    "                    TerminalColumns = new ParserStateColumn[]\r\n" +
                    "                    {\r\n";
                sourceFile.Write(tcPrefix);

                if (gis.TransitionsInOrder != null && gis.TransitionsInOrder.Count > 0)
                {
                    foreach (GrammarTransition gt in gis.TransitionsInOrder)
                        if (gt.IsReduction)
                            RenderStateTableRow(gt.Element, true, gt.Reduction.ProductionNumber);
                        else if (gt.IsShift)
                            RenderStateTableRow(gt.Element, false, gt.ShiftOrGoto.SetNumber);
                }
                sourceFile.Write("                    },\r\n");
            }
            else
                // No shifts or reductions so write empty array

                sourceFile.Write("                    TerminalColumns = new ParserStateColumn[0],\r\n");

            // GOTO part of table, used after a reduction from the uncovered state row

            if (hasGotos)
            {
                string ntPrefix =
                    "\r\n" +
                    "                    // GOTO non-terminals used to select next state\r\n" +
                    "                    // after a REDUCE operation has taken place\r\n" +
                    "\r\n" +
                    "                    NonterminalColumns = new ParserStateColumn[]\r\n" +
                    "                    {\r\n";
                sourceFile.Write(ntPrefix);
                foreach (GrammarTransition gt in gis.TransitionsInOrder.Where(t => t.IsGoto))
                    RenderStateTableRow(gt.Element, false, gt.ShiftOrGoto.SetNumber);

                sourceFile.Write("                    },\r\n");
            }
            else
                sourceFile.Write(
                    "\r\n" +
                    "                    NonterminalColumns = new ParserStateColumn[0],\r\n");

            sourceFile.WriteLine(
                "                },\r\n");
        }

        private void RenderStateTableRow(GrammarElement ge, bool reduce, int itemNumber)
        {
            bool isTerminal = ge.Token.TokenType == TokenType.Terminal;
            string useTab = (ge.Token.TokenNumber < 100) ? "\t" : "";

            // Output the type of token we are trying to match

            sourceFile.Write(
                "                        new ParserStateColumn\r\n" +
                "                        (\r\n" +
                $"                            {ge.Token.TokenNumber},\t{useTab}// On {ge.Token.Text}");

            // Generate the delegate that is called to evaluate
            // the guard condition. Because this is based on an
            // expression, we need to build the expression delegate

            if (ge.Guard == null)
                sourceFile.Write(
                    "\r\n                            null,\r\n");
            else
            {
                // Use the boolean expression cache to guarantee that each
                // boolean expression only appears once as a method in
                // the output parser.

                int guardProcNumber = grammar.BooleanExpressionCache.IndexOf(ge.Guard);
                if (guardProcNumber >= 0 && writtenGuards[guardProcNumber] < 0)
                {
                    string be = RenderBoolEvaluator(ge.Guard, "                ");
                    writtenGuards[guardProcNumber] = guardIndex;
                    guardProcs.Append(
                        $"                // Guard[{guardIndex++}]: {ge.Guard}\r\n" +
                        "\r\n" +
                        $"                {be},\r\n" +
                        "\r\n");
                }
                else if (guardProcNumber < 0)
                    throw new InvalidOperationException("Guard function not in boolean expression cache");

                sourceFile.Write(
                    $" if {ge.Guard}\r\n" +
                    $"                            table.Guards[{writtenGuards[guardProcNumber]}],\r\n");
            }

            // Render whether this is a shift or a reduction

            string moveType = "shift to";
            if (reduce)
                moveType = "reduce by";
            else if (!isTerminal)
                moveType = "goto";
            string strReduce = reduce ? "true" : "false";
            string strProdState = reduce ? "production" : "state";
            sourceFile.Write(
                $"                            {strReduce},\t// {moveType}\r\n");

            // Output the next state to jump to

            sourceFile.Write(
                    $"                            {itemNumber}\t\t// {strProdState} {itemNumber}\r\n" +
                    "                        ),\r\n");
        }

        /// <summary>
        /// Given a boolean expression tree, render it in
        /// a format that could appear in C# source code
        /// </summary>
        /// <param name="be">The boolean expression tree</param>
        /// <param name="indent">The number of characters
        /// to indent the output expression by</param>
        /// <returns>The C# representation of the guard condition</returns>

        public static string RenderBoolEvaluator(BoolExpr be, string indent)
        {
            // Try the node as a leaf element

            LeafExpr le = be as LeafExpr;
            if (le != null)
                return $"new LeafEvaluator(\"{le.Name}\")";

            // Try a not operator

            NotExpr ne = be as NotExpr;
            if (ne != null)
            {
                string argExpr = RenderBoolEvaluator(ne.Argument, indent + "    ");
                return
                    "new NotEvaluator\r\n" +
                    $"{indent}{{\r\n" +
                    $"{indent}    Arg = {argExpr}\r\n" +
                    $"{indent}}}";
            }

            // Try a binary AND operator

            AndExpr andExpr = be as AndExpr;
            if (andExpr != null)
            {
                string leftArg = RenderBoolEvaluator(andExpr.Left, indent + "    ");
                string rightArg = RenderBoolEvaluator(andExpr.Right, indent + "    ");
                return
                    "new AndEvaluator\r\n" +
                    $"{indent}{{\r\n" +
                    $"{indent}    Left = {leftArg},\r\n" +
                    $"{indent}    Right = {rightArg}\r\n" +
                    $"{indent}}}";
            }

            // Try a binary OR operator

            OrExpr orExpr = be as OrExpr;
            if (orExpr != null)
            {
                string leftArg = RenderBoolEvaluator(orExpr.Left, indent + "    ");
                string rightArg = RenderBoolEvaluator(orExpr.Right, indent + "    ");
                return
                    "new OrEvaluator\r\n" +
                    $"{indent}{{\r\n" +
                    $"{indent}    Left = {leftArg},\r\n" +
                    $"{indent}    Right = {rightArg}\r\n" +
                    $"{indent}}}";
            }

            // None of the above, so assume a null guard condititon

            return $"{indent}null";
        }

        /// <summary>
        /// Given a character string, render it in a
        /// form that could be used in C# source code.
        /// </summary>
        /// <param name="tabs">Number of four-character
        /// tab stops to begin each line with</param>
        /// <param name="s">The string to be rendered</param>
        /// <returns>The string as a C# source string</returns>

        public static string RenderAsCSharpString(int tabs, string s)
        {
            // Wrap the source string in a text reader
            // so that we can recover the text a line at
            // a time easily.

            using StringReader tr = new(s);
            string line;
            StringBuilder sb = new();
            while ((line = tr.ReadLine()) != null)
            {
                // At the end of every complete line
                // except the last one, use a '+'
                // character to append strings

                if (sb.Length > 0)
                    sb.AppendLine(" +");

                // Indent the desired number of tab stops

                for (int i = 0; i < tabs * 4; i++)
                    sb.Append(' ');

                // Double quotes in the string are to
                // be rendered as escaped double quotes

                line = Regex.Replace(line, "\"", "\\\"");

                // Bracket each line in double quotes,
                // explicitly placing the CRLF characters
                // into each line string.

                sb.Append($"\"{line}\\r\\n\"");
            }
            return sb.ToString();
        }

        private readonly StringBuilder actionProcs = new();
        private readonly StringBuilder guardProcs = new();
        private readonly List<string> actionProcsRendered = [];

        private void RenderInlineMergeAction(string tokenName, GrammarGuardOrAction gga)
        {
            sourceFile.Write($"\r\n        // GLR merge function for rules reducing to {tokenName}\r\n");

            // Now transform the code from grammar format
            // to a valid output method

            string code = gga.Code;

            // Replace the numbered parameters $0 or $1 with
            // their corresponding arguments from the object
            // array passed into the delegate action function.

            code = Regex.Replace(code, @"\$\$", "args[0]");
            code = Regex.Replace(code, @"\$0", "args[1]");
            code = Regex.Replace(code, @"\$1", "args[2]");

            sourceFile.Write(
                "\r\n" +
                $"        public void Merge{tokenName}(NonterminalToken[] args)\r\n" +
                "        {\r\n");
            sourceFile.Write(RationaliseCode(code));
            sourceFile.Write(
                "        }\r\n");
        }

        private void RenderNewProduction(GrammarProduction prod, List<GrammarProduction> prodList)
        {
            sourceFile.Write(
                "                new ParserProduction\r\n" +
                "                (\r\n");
            sourceFile.WriteLine(
                $"                    {prod.ProductionNumber}, {prod.NonterminalRuleNumber}, " +
                $"\"{prod}\",");
            string codeComma = (prod.Code != null) ? "," : " ";
            sourceFile.Write(
                $"                    {prod.RHS.Count}, {prod.LHS.TokenNumber}{codeComma}\t// {prod.LHS.Text}");

            // Generate the output anonymous delegate function that
            // will be the implementation of the reduction action code

            if (prod.Code != null)
            {
                if (!actionProcsRendered.Contains(prod.Code.Name))
                {
                    // Mark this action function as having been written

                    actionProcsRendered.Add(prod.Code.Name);

                    // Single out the multiplicity methods for
                    // special handling, as they are kept weakly
                    // typed so that they can be shared between rules.

                    bool forceWeakTyping =
                        prod.Code.Name == "EmptyList"
                        || prod.Code.Name == "EarliestNonterminalInList"
                        || prod.Code.Name == "LatestNonterminalInList";

                    // Now transform the code from grammar format
                    // to a valid output method

                    string code = prod.Code.Code;

                    // Find out if the $$ parameter is actually used
                    // in the action code for this rule reduction

                    bool argZeroUsed = Regex.IsMatch(code, @"\$\$");
                    bool argZeroUntyped = string.IsNullOrEmpty(prod.LHS.ValueType)
                        || forceWeakTyping
                        || prod.LHS.ValueType == "object"
                        || prod.LHS.ValueType == "Object"
                        || prod.LHS.ValueType == "System.Object";

                    // Replace the numbered parameters $0 ... $n-1 with
                    // their corresponding arguments from the object
                    // array passed into the delegate action function.

                    if (argZeroUntyped)
                        code = Regex.Replace(code, @"\$\$", "(args[0])");
                    else
                        code = Regex.Replace(code, @"\$\$", "arg0");

                    DollarParameterReplacer dpr = new(prod, forceWeakTyping);
                    code = Regex.Replace(code, @"\$([0-9]+)", dpr.ReplacementDollarParameter);

                    // Gather the list of productions that use this
                    // action function, and make a single comment
                    // into the output source code that lists them.

                    string actionComment = string.Empty;
                    foreach (GrammarProduction grp in prodList)
                        if (grp.Code == prod.Code)
                            actionComment += $"        // {grp}\r\n";

                    if (actionProcs.Length != 0)
                        actionProcs.AppendLine();
                    actionProcs.Append(
                        $"{actionComment}\r\n" +
                        $"        public void {prod.Code.Name}(object[] args)\r\n" +
                        "        {\r\n" +
                        $"{dpr.Declarations}");

                    if (!argZeroUntyped && argZeroUsed)
                        actionProcs.Append
                        (
                            "            try\r\n" +
                            "            {\r\n"
                        );
                    actionProcs.Append(RationaliseCode(code, !argZeroUntyped && argZeroUsed));
                    if (!argZeroUntyped && argZeroUsed)
                        actionProcs.Append
                        (
                            "            }\r\n" +
                            "            finally\r\n" +
                            "            {\r\n" +
                            "                args[0] = arg0!;\r\n" +
                            "            }\r\n"
                        );
                    actionProcs.Append("        }\r\n");
                }
                sourceFile.Write(
                    "\r\n" +
                    "                    new ParserInlineAction" +
                    $"(\"{prod.Code.Name}\")");
            }

            sourceFile.WriteLine(
                "\r\n                ),\r\n");
        }

        public static string RationaliseCode(string code, bool indentForTryFinally = false)
        {
            string primaryIndent = "            ";
            if (indentForTryFinally)
                primaryIndent += "    ";

            StringBuilder sb = new();
            List<string> lines = [];

            // First find out what the minimum shared
            // indentation is for the code fragment

            int minLeadingSpaces = -1;
            using (StringReader tr = new(code))
            {
                string ipLine;
                while ((ipLine = tr.ReadLine()) != null)
                    lines.Add(ipLine);
            }

            // Strip first and last lines, if
            // they are empty or white space only

            if (IsEmptyLine(lines[0]))
                lines.RemoveAt(0);
            if (IsEmptyLine(lines.Last()))
                lines.RemoveAt(lines.Count - 1);

            // Skip blank lines

            foreach (string line in lines)
            {
                if (line.Length == 0)
                    continue;

                // Count the number of leading spaces

                int nSpaces = 0;
                int i;
                for (i = 0; i < line.Length && (line[i] == ' ' || line[i] == '\t'); i++)
                    if (line[i] == '\t')
                        nSpaces = (nSpaces + 4) & ~3;
                    else
                        nSpaces++;
                if (i < line.Length && (nSpaces < minLeadingSpaces || minLeadingSpaces < 0))
                    minLeadingSpaces = nSpaces;
            }

            // Now adjust the indentation to align with code output

            foreach (string line in lines)
            {
                // Find the character position in the
                // line of the character that sits at
                // the leftmost non-whitespace character
                // in the whole code block. This is
                // complicated by the fact that tab
                // characters have to be dealt with.

                int i;
                int nSpaces = 0;
                for (i = 0; i < line.Length; i++)
                {
                    // Skip characters until we reach
                    // the indented column of interest

                    if (line[i] == '\t')
                        nSpaces = (nSpaces + 4) & ~3;
                    else
                        nSpaces++;
                    if (nSpaces > minLeadingSpaces)
                        break;
                }

                // Now adjust the line so that the
                // correct number of leading spaces appear
                // on the front of the line.

                if (i >= line.Length)
                    sb.AppendLine();
                else
                    sb.AppendLine(string.Concat(primaryIndent, line.AsSpan(i)));
            }
            return sb.ToString();
        }

        // Check to see if the line has only white space characters

        private static bool IsEmptyLine(string s)
        {
            foreach (char c in s)
                if (!char.IsWhiteSpace(c))
                    return false;
            return true;
        }
    }
}
