// This source code is based on code written for Ropley Information
// Technology Ltd. (RIT), and is offered for public use without warranty.
// You are entitled to edit or extend this code for your own purposes,
// but use of any unmodified parts of this code does not grant
// the user exclusive rights or ownership of that unmodified code. 
// While every effort has been made to deliver quality software, 
// there is no guarantee that this product offered for public use
// is without defects. The software is provided "as is," and you 
// use the software at your own risk. No warranties are made as to 
// performance, merchantability, fitness for a particular purpose, 
// nor are any other warranties expressed or implied. No oral or 
// written communication from or information provided by RIT 
// shall create a warranty. Under no circumstances shall RIT
// be liable for direct, indirect, special, incidental, or 
// consequential damages resulting from the use, misuse, or 
// inability to use this software, even if RIT has been
// advised of the possibility of such damages. Downloading
// opening or using this file in any way will constitute your 
// agreement to these terms and conditions. Do not use this 
// software if you do not agree to these terms.

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Parsing
{
    /// <summary>
    /// This class is the user façade onto the parser
    /// and its associated classes. It provides a simple
    /// interface for using the parser generator in
    /// each of its operating modes.
    /// </summary>
    /// <typeparam name="T">The type of the
    /// application-specific parser class
    /// </typeparam>

    public static class ParserFactory<T> where T : IParser, new()
    {
        private static ParserTable parserTable;

        /// <summary>
        /// The parser table used by the parser instances created by
        /// this parser factory. This is initialised here if an
        /// offline parser class has been compiled into this application. 
        /// It needs to be initialised by parsing and compiling a grammar
        /// input file before attempting to create any parser instances, 
        /// if an inline parser is being used. This is done by calling
        /// the method InitializeFromGrammar() before using this property.
        /// </summary>

        public static ParserTable ParserTable
        {
            get
            {
                if (parserTable == null)
                {
                    CompilerLoader<T> loader = new CompilerLoader<T>();
                    Type parserType = loader.GetDerivedType(typeof(T).Assembly);
                    if (parserType != null)
                    {
                        parserTable = (ParserTable)parserType
                            .GetMethod("InitParserTable")
                            .Invoke(null, null);
                    }
                    else
                        throw new InvalidOperationException
                        (
                            "Could not load the assembly containing the autogenerated " +
                            "parser class derived from " + typeof(T).FullName +
                            ". Use ParseLR to generate source code for the offline " +
                            "parser, and add it to your project."
                        );
                }
                return parserTable;
            }
        }

        /// <summary>
        /// Rapid access to the token name/value lookup table for the state machine
        /// </summary>

        public static TwoWayMap<string, int> Tokens => ParserTable.Tokens;

        /// <summary>
        /// Initialise a parser factory for an inline parser. Given
        /// the parser class T, this method needs to deduce the
        /// type of the corresponding autogenerated parser class that
        /// is derived from it, compile the source code into a loaded
        /// dynamic assembly, then create an instance of its ParserTable.
        /// </summary>
        /// <param name="grammar">The input source code</param>
        /// <param name="compressParser">True to apply
        /// Pager's algorithm for parser table compression. If
        /// false, merely numbers the item sets without
        /// removing any of them.</param>
        /// <param name="supportErrorRecovery">True to support
        /// the yacc/bison style error recovery when reading
        /// the input grammar from which the offline parser
        /// is constructed.</param>
        /// <param name="generalisedParser">True to
        /// generate a source file suitable for
        /// use as a generalised LR(1) parser. False
        /// for a traditional LR(1) parser.</param>
        /// <param name="sourceOutput">Optional
        /// parameter to output the autogenerated
        /// parser source code. Omit or set
        /// to null to ignore the source code.</param>

        public static void InitializeFromGrammar
        (
            string grammar,
            bool compressParser,
            bool supportErrorRecovery,
            bool generalisedParser,
            TextWriter sourceOutput = null
        )
        {
            using StringReader srg = new StringReader(grammar);
            InitializeFromGrammar
            (
                srg,
                null,
                compressParser,
                supportErrorRecovery,
                generalisedParser,
                sourceOutput
            );
        }


        /// <summary>
        /// Initialise a parser factory for an inline parser. Given
        /// the parser class T, this method needs to deduce the
        /// type of the corresponding autogenerated parser class that
        /// is derived from it, compile the source code into a loaded
        /// dynamic assembly, then create an instance of its ParserTable.
        /// </summary>
        /// <param name="input">The input text stream containing the
        /// source code</param>
        /// <param name="tabOutput">Optional output stream
        /// for a text file describing the structure of the
        /// created parser. Set null if not needed.</param>
        /// <param name="compressParser">True to apply
        /// Pager's algorithm for parser table compression. If
        /// false, merely numbers the item sets without
        /// removing any of them.</param>
        /// <param name="supportErrorRecovery">True to support
        /// the yacc/bison style error recovery when reading
        /// the input grammar from which the offline parser
        /// is constructed.</param>
        /// <param name="generalisedParser">True to
        /// generate a source file suitable for
        /// use as a generalised LR(1) parser. False
        /// for a traditional LR(1) parser.</param>
        /// <param name="sourceOutput">Optional output stream for
        /// autogenerated source code while the LR parsing process
        /// is in progress. Set null or omit if not needed.</param>

        public static void InitializeFromGrammar
        (
            TextReader input,
            TextWriter tabOut,
            bool compressParser,
            bool supportErrorRecovery,
            bool generalisedParser,
            TextWriter sourceOutput = null
        )
        {
            List<string> assemblyRefs;
            StringBuilder parserSource = new StringBuilder();
            using (StringWriter sourceWriter = new StringWriter(parserSource))
            {
                // Generate the source code for the autogenerated
                // derived parser class into a string builder so
                // that it can then be compiled inline.

                CompilerErrors =
                    ParserFactory.CreateOfflineParser
                    (
                        input,
                        sourceWriter,
                        tabOut,
                        null,
                        compressParser,
                        supportErrorRecovery,
                        generalisedParser,
                        out assemblyRefs
                    );

                if (!string.IsNullOrEmpty(CompilerErrors)
                    && CompilerErrors.StartsWith("Failed to create parser"))
                    throw new ArgumentException(CompilerErrors);
            }

            // Write out the source code if the sourceOutput
            // argument points at a valid TextWriter

            if (sourceOutput != null)
                sourceOutput.Write(parserSource);

            // Compile the parser source into an in-memory
            // assembly so that an instance can be created.

            CompilerLoader<T> loader = new CompilerLoader<T>();
            Type parserType = loader.CompileAutogenAssembly(parserSource, assemblyRefs);
            CompilerErrors = loader.CompilerErrors;

            // Load the type, and run its static InitParserTable method
            // so that we have an initialised parser table to use when
            // creating instances.

            if (parserType != null)
            {
                parserTable = (ParserTable)parserType
                    .GetMethod("InitParserTable")
                    .Invoke(null, null);
            }
            else
                throw new ArgumentException
                    ("Could not compile the inline parser assembly. " + CompilerErrors);
        }

        /// <summary>
        /// Create an instance of a parser based on the tables
        /// initialised within the parser factory for type T.
        /// </summary>
        /// <typeparam name="T">The type of the derived
        /// parser class we want to create. Note that this
        /// derived parser class must have a default
        /// constructor or no constructor at all, and
        /// must obviously be inherited from Parser.</typeparam>
        /// <returns>A new parser</returns>

        public static T CreateInstance() => ParserTable.CreateParser<T>();

        /// <summary>
        /// When building an inline parser, the compiler is
        /// run silently in the background. If the input grammar
        /// contained errors, they will pop up here for parser
        /// type of T.
        /// </summary>

        public static string CompilerErrors
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// Non-generic parser factory used for creation of
    /// output source code for a parser from an input
    /// grammar description.
    /// </summary>

    public static class ParserFactory
    {
        /// <summary>
        /// Create the C# source code for a new parser based on
        /// the input grammar.
        /// </summary>
        /// <param name="grammar">The grammar for the new
        /// parser</param>
        /// <param name="output">The output stream to which
        /// the new source code is written</param>
        /// <param name="tabOutput">Optional output stream
        /// for a text file describing the structure of the
        /// created parser. Set null if not needed.</param>
        /// <param name="debugOutput">Optional output stream for
        /// parser debugging while the LR parsing process is
        /// in progress. Set null if not needed.</param>
        /// <param name="compressParser">True to apply
        /// Pager's algorithm for parser table compression. If
        /// false, merely numbers the item sets without
        /// removing any of them.</param>
        /// <param name="supportErrorRecovery">True to support
        /// the yacc/bison style error recovery when reading
        /// the input grammar from which the offline parser
        /// is constructed.</param>
        /// <param name="generalisedParser">True to
        /// generate a source file suitable for
        /// use as a generalised LR(1) parser. False
        /// for a traditional LR(1) parser.</param>
        /// <returns>The error message string from the
        /// parsing process. If string.Empty, the
        /// parser successfully generated an output
        /// parser.</returns>

        public static string CreateOfflineParser
        (
            string grammar,
            TextWriter output,
            TextWriter tabOutput,
            TextWriter debugOutput,
            bool compressParser,
            bool supportErrorRecovery,
            bool generalisedParser,
            out List<string> assemblyRefs
        )
        {
            using StringReader sr = new StringReader(grammar);
            return CreateOfflineParser
            (
                sr,
                output,
                tabOutput,
                debugOutput,
                compressParser,
                supportErrorRecovery,
                generalisedParser,
                out assemblyRefs
            );
        }

        /// <summary>
        /// Create the C# source code for a new parser based on
        /// the input grammar.
        /// </summary>
        /// <param name="input">The input stream from which
        /// the input grammar is read.</param>
        /// <param name="output">The output stream to which
        /// the new source code is written</param>
        /// <param name="tabOutput">Optional output stream
        /// for a text file describing the structure of the
        /// created parser. Set null if not needed.</param>
        /// <param name="debugOutput">Optional output stream for
        /// parser debugging while the LR parsing process is
        /// in progress. Set null if not needed.</param>
        /// <param name="compressParser">True to apply
        /// Pager's algorithm for parser table compression. If
        /// false, merely numbers the item sets without
        /// removing any of them.</param>
        /// <param name="supportErrorRecovery">True to support
        /// the yacc/bison style error recovery when reading
        /// the input grammar from which the offline parser
        /// is constructed.</param>
        /// <param name="generalisedParser">True to
        /// generate a source file suitable for
        /// use as a generalised LR(1) parser. False
        /// for a traditional LR(1) parser.</param>
        /// <param name="referencedAssemblies">
        /// An empty list of strings that will
        /// be filled in with names of DLLs
        /// explicitly referenced from the options
        /// section of the parsed grammar.</param>
        /// <returns>The error message string from the
        /// parsing process. If string.Empty, the
        /// parser successfully generated an output
        /// parser.</returns>

        public static string CreateOfflineParser
        (
            TextReader input,
            TextWriter output,
            TextWriter tabOutput,
            TextWriter debugOutput,
            bool compressParser,
            bool supportErrorRecovery,
            bool generalisedParser,
            out List<string> referencedAssemblies
        )
        {
            StringBuilder errOutput = new StringBuilder();
            referencedAssemblies = new List<string>();
            try
            {
                // Create an LR(1) parser to parse the grammar string.
                // Parse the grammar string to create the internal
                // grammar tables from which an inline parser could
                // be constructed.

                LRParser lrParser = ParserFactory<LRParser>.CreateInstance();
                lrParser.OutputParserSupportsErrorRecovery
                    = supportErrorRecovery;
                lrParser.DebugStream = debugOutput;

                lrParser.ErrStream = new StringWriter(errOutput);

                bool success = lrParser.Parse
                (
                    new Parsing.Tokeniser
                    (
                        input,
                        lrParser.ParserTable.Tokens
                    )
                );

                // Go no further if the input grammar was faulty

                if (!success)
                    return "Failed to create parser:\r\n" + errOutput;

                // Create the item sets that describe
                // the parser's finite state machine.
                // The argument to CreateItemSetsAndGotoEntries
                // below should be set true if building a GLR
                // style of parser.

                string validationResult = lrParser.ConstructedGrammar
                    .CreateItemSetsAndGotoEntries(generalisedParser);
                if (!string.IsNullOrEmpty(validationResult))
                {
                    lrParser.ErrStream.WriteLine(validationResult);
                    return "Failed to create parser:\r\n" + errOutput;
                }

                // Apply Pager's algorithm to optimise away unnecessary states

                lrParser.ConstructedGrammar.CompressItemSets
                    (compressParser && !generalisedParser);

                // Set up the preferred order for shifts and reductions in each
                // parser state. Also check for grammar ambiguities caused by
                // ill-chosen guard conditions. THis reordering really isn't needed
                // for a GLR parser as all options are considered. However, there
                // are side effects associated with initialising the item sets
                // build into the ordering algorithm, as the TransitionsInOrder
                // property is filled in by this method, and then used on item
                // sets later whether GLR or not. Code might be improved here.

                string errMessage = lrParser.ConstructedGrammar
                    .EstablishShiftReduceOrdersForItemSets();
                if (!generalisedParser && !string.IsNullOrEmpty(errMessage))
                    lrParser.ErrStream.WriteLine(errMessage);

                // Generate the output parser tables

                GrammarOutput parserGenerator = new GrammarOutput(output);
                parserGenerator.RenderStateTables
                (
                    lrParser.ConstructedGrammar,
                    tabOutput != null,
                    supportErrorRecovery,
                    generalisedParser
                );

                // Form the list of externally referenced assemblies
                // explicitly listed in the options section of the grammar

                referencedAssemblies = lrParser.ConstructedGrammar
                    .Options["assemblyrefs"] as List<string>;

                // Dump the table details to textual table description

                OutputParserTables(tabOutput, lrParser);

                // Empty returned string implies the method was successful

                if (errOutput.Length > 0)
                    return "Parser created with warnings:\r\n" + errOutput;
                else
                    return string.Empty;
            }
            catch (Exception x)
            {
                errOutput.AppendLine("Unexpected exception:\r\n" + x.Message);
                errOutput.AppendLine("Stack trace: " + x.StackTrace);
                return "Failed to create parser:\r\n" + errOutput;
            }
        }

        private static void OutputParserTables(TextWriter tabOutput, LRParser lrParser)
        {
            if (tabOutput != null)
            {
                string prods = lrParser.ConstructedGrammar.RenderProductions();
                string itemSets = lrParser.ConstructedGrammar.RenderItemSetsAndGotos();
                tabOutput.Write(prods);
                tabOutput.Write(itemSets);
            }
        }
    }
}
