// This source code is based on code written for Ropley Information
// Technology Ltd. (RIT), and is offered for public use without warranty.
// You are entitled to edit or extend this code for your own purposes,
// but use of any unmodified parts of this code does not grant
// the user exclusive rights or ownership of that unmodified code. 
// While every effort has been made to deliver quality software, 
// there is no guarantee that this product offered for public use
// is without defects. The software is provided "as is," and you 
// use the software at your own risk. No warranties are made as to 
// performance, merchantability, fitness for a particular purpose, 
// nor are any other warranties expressed or implied. No oral or 
// written communication from or information provided by RIT 
// shall create a warranty. Under no circumstances shall RIT
// be liable for direct, indirect, special, incidental, or 
// consequential damages resulting from the use, misuse, or 
// inability to use this software, even if RIT has been
// advised of the possibility of such damages. Downloading
// opening or using this file in any way will constitute your 
// agreement to these terms and conditions. Do not use this 
// software if you do not agree to these terms.

using ParserGenerator;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Parsing
{
    public class FSMOutput
    {
        private static readonly string banner =
            "// AUTOGENERATED CODE FROM PARSELR STATE MACHINE GENERATOR. DO NOT EDIT.\r\n" +
            "//\r\n" +
            "// Date generated: {0:r}\r\n" +
            "// This code represents the hidden derived class from the\r\n" +
            "// application-specific state machine class, iteself derived from\r\n" +
            "// Parsing.FSM. There should be no need to edit this file.\r\n" +
            "\r\n";

        private readonly TextWriter outStr;

        public FSMOutput(TextWriter srcFile)
        {
            if (srcFile == null)
                throw new ArgumentException("Need a valid output stream to write source code");
            else
                outStr = srcFile;
            inlineActionSource = new StringBuilder();
        }

        // Names of classes containing guard and action functions

        private string nameSpace;
        private string usersFSMClassName;
        private Grammar grammar;

        /// <summary>
        /// Given a grammar for a finite state machine, generate the output source code
        /// for that state machine's transition tables, guards and actions.
        /// </summary>
        /// <param name="inputGrammar">The input string containing the grammar to be read</param>
        /// <param name="ignoreErrorEvents">True to make a machine that drops unrecognised
        /// input event/guard compinations, false to halt on first occurrence</param>
        /// <param name="assemblyRefs">Where the list of explicitly named DLLs
        /// we need references to is constructed</param>
        /// <returns>An error message if the code creation fails, string.Empty if successful</returns>


        public string BuildSource(string inputGrammar, bool ignoreErrorEvents, out List<string> assemblyRefs)
        {
            using TextReader reader = new StringReader(inputGrammar);
            return BuildSource(reader, ignoreErrorEvents, out assemblyRefs);
        }

        /// <summary>
        /// Given a grammar for a finite state machine, generate the output source code
        /// for that state machine's transition tables, guards and actions.
        /// </summary>
        /// <param name="inStr">The input stream from which the grammar will be read</param>
        /// <param name="ignoreErrorEvents">True to make a machine that drops unrecognised
        /// input event/guard combinations, false to halt on first occurrence</param>
        /// <param name="assemblyRefs">Where the list of explicitly named DLLs
        /// we need references to is constructed</param>
        /// <returns>An error message if the code creation fails, string.Empty if successful</returns>

        public string BuildSource(TextReader inStr, bool ignoreErrorEvents, out List<string> assemblyRefs)
        {
            assemblyRefs = [];
            try
            {
                if (outStr == null)
                    throw new ArgumentException("Need a valid output stream to write source code");

                // Use an LR parser to read the grammar description

                LRParser p = ParserFactory<LRParser>.CreateInstance();
                StringBuilder errBuilder = new();
                p.ErrStream = new StringWriter(errBuilder);
                bool successful = p.Parse
                (
                    new Tokeniser
                    (
                        inStr,
                        p.ParserTable.Tokens
                    )
                );

                // If the parser failed to scan the input grammar correctly,
                // report the error from the parser back to the caller via the
                // Error property.

                if (!successful)
                    return errBuilder.ToString();

                // It could have been a valid grammar, but not a valid
                // state machine. For example the input grammar might
                // have been a valid LR grammar for a parser. Check
                // that the vital signs for an output state machine
                // are present, and if not, report errors on this.

                grammar = p.ConstructedGrammar;
                if (grammar.StartingState == null
                    || grammar.MachineStates.Count == 0)
                    return "Grammar was not a valid state machine grammar.";

                // Create a token nume value lookup table

                TwoWayMap<string, int> tokenMap = new();

                // Capture the input event types into the token map

                foreach (GrammarToken tok in grammar.Terminals)
                    tokenMap.Add(tok.Text, tok.TokenNumber);

                // Default names for the namespace and derived FSM class

                nameSpace = "StateMachine";
                usersFSMClassName = "MyFSM";

                // Capture the options from the dictionary

                List<string> usings = null;

                // Pull in the using namespaces and the
                // namespace for the fsm if available

                if (grammar.Options != null)
                {
                    if (grammar.Options.TryGetValue("usings", out object value))
                        usings = value as List<string>;
                    if (grammar.Options.TryGetValue("namespace", out value))
                        nameSpace = value.ToString();
                    if (grammar.Options.TryGetValue("fsmclass", out value))
                        usersFSMClassName = value.ToString();
                }

                // Form the list of externally referenced assemblies
                // explicitly listed in the options section of the grammar

                assemblyRefs = p.ConstructedGrammar
                    .Options["assemblyrefs"] as List<string>;

                // First render the banner at the top of the new source file

                outStr.Write(banner, DateTime.Now, usersFSMClassName, nameSpace);

                // If the user has set parser-generated
                // alternatives for the list of using
                // statements, use these. Otherwise, use
                // a default set that will allow the
                // fsm to compile successfully.

                if (usings != null && usings.Count > 0)
                    foreach (string u in usings)
                        outStr.WriteLine($"using {u};");
                else
                {
                    outStr.Write(
                        "using System;\r\n" +
                        "using System.Collections.Generic;\r\n" +
                        "using System.Linq;\r\n" +
                        "using System.Text;\r\n" +
                        "using System.IO;\r\n");
                }

                // Handle fsms created in users' namespaces

                if (nameSpace != "Parsing")
                    outStr.Write("using Parsing;\r\n");

                // Output the namespace name to be used at the
                // top of the fsm. By default this is
                // LRParser at the top namespace level.

                outStr.WriteLine($"\r\nnamespace {nameSpace}.AutoGenerated\r\n{{");

                // Output the finite state machine state tables,
                // beginning with the fixed top parts of the
                // FSM derived class.

                RenderFSMTablePrefix();

                // Begin the construction of the state table rows

                outStr.Write(
                    "            // Create the state table\r\n" +
                    "\r\n" +
                    $"            FSMState[] states = new FSMState[{grammar.MachineStates.Count}];\r\n" +
                    "            FSMTransition[] transitions;\r\n\r\n");

                // Create an array of state names so that we can
                // look up the array indexes of states by name

                string[] stateNames = new string[grammar.MachineStates.Count];

                // If we get here, the chances are that we have an
                // acceptable finite state machine description. In
                // that case, we shall create the state transition
                // tables that will become the returned data.

                int stateIndex = 1;

                foreach (State s in grammar.MachineStates)
                {
                    outStr.Write($"            // State {s.StateName.Text}\r\n\r\n");

                    // Determine whether this is the entry state
                    // for the state machine. The entry state is
                    // always placed in slot zero of the array.

                    int currStateIndex;
                    if (s == grammar.StartingState)
                        currStateIndex = 0;
                    else
                        currStateIndex = stateIndex++;

                    // Render the new state object

                    string nActions = BuildOutputAction
                        ("EntryActions", "On" + s.StateName.Text + "Entry", s.EntryCode);
                    string xActions = BuildOutputAction
                        ("ExitActions", "On" + s.StateName.Text + "Exit", s.ExitCode);

                    outStr.Write(
                        $"            states[{currStateIndex}] = new FSMState\r\n" +
                        $"            {{\r\n" +
                        $"                Name = \"{s.StateName.Text}\",\r\n" +
                        $"                {nActions},\r\n" +
                        $"                {xActions}\r\n" +
                        $"            }};\r\n\r\n");

                    // Remember the index positions of each named state
                    // by storing the state names into an array of strings
                    // in the same order as the states in the output file.

                    stateNames[currStateIndex] = s.StateName.Text;
                }

                // Now we have output the FSMState list,
                // we need to walk the list of states 
                // filling in the transition lists.

                foreach (State s in grammar.MachineStates)
                {
                    // Find the corresponding output runtime state

                    stateIndex = Array.IndexOf<string>(stateNames, s.StateName.Text);

                    // Create the array for this state's transition objects

                    outStr.Write(
                        $"            // Transitions for state {s.StateName.Text}\r\n\r\n" +
                        $"            transitions = new FSMTransition[{s.Transitions.Count}];\r\n" +
                        $"            states[{stateIndex}].Transitions = transitions;\r\n\r\n");

                    // Populate the array with the set of transitions for this state

                    int idx = 0;
                    foreach (StateTransition st in s.Transitions)
                    {
                        string tState = st.TargetState == null ? "null" : st.TargetState.Text;
                        string teg = st.TransitionEventAndGuard.Guard != null ?
                            "[" + st.TransitionEventAndGuard.Guard.ToString() + "]" : "";
                        outStr.Write
                        (
                            $"            // {s.StateName.Text}: " +
                            $"{st.TransitionEventAndGuard.Token.Text}{teg} {tState}\r\n\r\n"
                        );

                        // Lookup the index for the FSMState in the state array
                        // that will be the next state this transition jumps to.

                        int targetStateIndex = -1;
                        if (st.TargetState != null)
                            targetStateIndex = Array.IndexOf<string>
                                (stateNames, st.TargetState.Text);

                        // Construct the argument to be used for the
                        // guard condition within the transition

                        string guardArgument = "null";
                        if (st.TransitionEventAndGuard.Guard != null)
                            guardArgument = GrammarOutput.RenderBoolEvaluator
                                (st.TransitionEventAndGuard.Guard, "                ");

                        // Now output the actual new transition object creation code

                        string opAction = BuildOutputAction("InlineActions", "On" + s.StateName.Text + "Transition" + idx, st.Code);
                        string strStates = targetStateIndex >= 0
                            ? ("states[" + targetStateIndex + "]")
                            : "null";
                        string tgtState = st.TargetState == null ?
                            "(Terminates)" : st.TargetState.Text;
                        outStr.Write(
                            $"            transitions[{idx}] = new FSMTransition\r\n" +
                            $"            {{\r\n" +
                            $"                InputToken = {st.TransitionEventAndGuard.Token.TokenNumber},  // {st.TransitionEventAndGuard.Token.Text}\r\n" +
                            $"                Condition = {guardArgument},\r\n" +
                            $"                {opAction},\r\n" +
                            $"                NextState = {strStates}  // {tgtState}\r\n" +
                            $"            }};\r\n\r\n");
                        idx++;
                    }
                }

                // Create the table object and populate its members

                string strIgnoreErrEvents = ignoreErrorEvents ? "true" : "false";
                outStr.Write(
                    "            // Return a new FSM Table to the caller\r\n" +
                    "\r\n" +
                    $"            FSMTable newTable = new FSMTable(states, tokens, {strIgnoreErrEvents});\r\n" +
                    $"            newTable.InitializeFSMConstructor(typeof({usersFSMClassName}_AutoGenerated));\r\n" +
                    "            return newTable;\r\n" +
                    $"        }}\r\n");

                // Output the source code for any inline guard functions

                RenderGuardFunctions(p.ConstructedGrammar.GuardBodies);

                // Output any inline action code that was written into the grammar

                if (inlineActionSource.Length > 0)
                    outStr.Write(inlineActionSource.ToString());

                // Close the class and namespace

                outStr.Write(
                    $"    }}\r\n" +
                    $"}}\r\n");

                return string.Empty;
            }
            catch (Exception x)
            {
                return $"Error building source output: {x.Message}\r\nStack trace: {x.StackTrace}";
            }
        }

        /// <summary>
        /// Output code that initialises one inline action list into a variable
        /// </summary>
        /// <param name="actionRef">Variable into which the action list will be assigned</param>
        /// <param name="actionName">The name to be used for the action function
        /// if there was a single anonymous action in the list. In this case, the
        /// default name is provided and the function is added to the source output code.</param>
        /// <param name="gga">The list of guards or actions from which the source code
        /// for the list of actions will be compiled</param>
        /// <returns>True if a list was assigned, false if no assignment</returns>

        private string BuildOutputAction(string actionRef, string actionName, GrammarGuardOrAction gga)
        {
            string result = $"{actionRef} =";

            // Return source code for an empty action list
            // if this transition has no action to execute

            if (gga == null)
                return $"{result} null";

            // Handle the special case of inline code, where the actual source code
            // was embedded in the grammar, but the action has no method name.

            if (string.IsNullOrEmpty(gga.Name) && !string.IsNullOrEmpty(gga.Code))
            {
                gga.Name = actionName;
                EmitActionCode(gga);
            }

            // Output the initialisation that will cause
            // a runtime bind to the action function.

            return $"{result} new FSMInlineAction(\"{gga.Name}\")";
        }

        private readonly StringBuilder inlineActionSource;

        private void EmitActionCode(GrammarGuardOrAction code)
        {
            if (inlineActionSource.Length == 0)
                inlineActionSource.Append
                    ("\r\n        // Inline action functions from FSM grammar\r\n");
            inlineActionSource.Append
            (
                "\r\n" +
                $"        public void {code.Name}()\r\n" +
                $"        {{\r\n"
            );
            inlineActionSource.Append(GrammarOutput.RationaliseCode(code.Code));
            inlineActionSource.Append("        }\r\n");
        }

        /// <summary>
        /// Append the list of inline guard functions
        /// onto the end of the parser class.
        /// </summary>
        /// <param name="list">The list of identified guards</param>

        private void RenderGuardFunctions(List<GrammarGuardOrAction> list)
        {
            List<GrammarGuardOrAction> inlineGuards = list.Where(gg => !string.IsNullOrEmpty(gg.Code)).ToList();
            if (inlineGuards.Count > 0)
                inlineActionSource.Append(
                    "\r\n" +
                    "        // Inline guard functions from FSM grammar\r\n");

            foreach (GrammarGuardOrAction gg in inlineGuards)
            {
                inlineActionSource.Append(
                    "\r\n" +
                    $"        public bool {gg.Name}()\r\n" +
                    $"        {{\r\n");

                // Now transform the code from the grammar format
                // to a valid output method

                inlineActionSource.Append(GrammarOutput.RationaliseCode(gg.Code));
                inlineActionSource.Append("        }\r\n");
            }
        }

        private void RenderFSMTablePrefix()
        {
            string prefix =
                "    /// <summary>\r\n" +
                "    /// Implements the auto-generated part of the user-specific\r\n" +
                "    /// state machine class. This gives the action functions and guards\r\n" +
                "    /// in-class access to the contents of the user-specific FSM.\r\n" +
                "    /// </summary>\r\n" +
                "\r\n" +
                $"    public class {usersFSMClassName}_AutoGenerated : {usersFSMClassName}\r\n" +
                $"    {{\r\n" +
                "        /// <summary>\r\n" +
                "        /// Initialiser for source-code FSM\r\n" +
                "        /// generator that is subsequently compiled to\r\n" +
                "        /// obtain the new run-time code.\r\n" +
                "        /// </summary>\r\n" +
                "\r\n" +
                "        public static FSMTable InitFSMTable()\r\n" +
                $"        {{\r\n";


            outStr.Write(prefix);

            // Set up the token list

            outStr.Write(
                "            // Event, guard and action names/values for debugging\r\n\r\n" +
                "            TwoWayMap<string, int> tokens = new TwoWayMap<string, int>();\r\n");

            // Create the terminal token members of the enum

            foreach (GrammarToken tok in grammar.Terminals.OrderBy(t => t.TokenNumber))
                if (tok.Text != "ERR")
                    outStr.Write(
                        $"            tokens.Add(\"{tok.Text}\", {tok.TokenNumber});\r\n");

            // Render the lines that fit between the terminal
            // and non-terminal tokens

            outStr.Write(
                "\r\n" +
                "            // State names and values\r\n" +
                "\r\n");

            // Now output the non terminal symbols

            foreach (GrammarToken ntTok in grammar.Nonterminals.OrderBy(t => t.TokenNumber))
                outStr.Write(
                    $"            tokens.Add(\"{ntTok.Text}\", {ntTok.TokenNumber});\r\n");

            outStr.WriteLine();
        }
    }
}
